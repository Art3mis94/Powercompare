<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Compare Players — Power Trends (Local)</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<style>
body{margin:0;font-family:Inter,sans-serif;background:#f8fafc;color:#1e293b;}
header{background:#1e40af;color:#fff;padding:1rem 1.5rem;display:flex;justify-content:space-between;align-items:center;}
header h1{margin:0;font-size:1.5rem;font-weight:600;}
/* Sign Out button style kept for consistency, but button removed from HTML */
button.signOut{padding:.5rem 1rem;border-radius:6px;border:none;background:#3b82f6;color:#fff;cursor:pointer;}
button.signOut:hover{opacity:.9;}
nav{display:flex;justify-content:center;gap:10px;padding:.75rem;background:#e2e8f0;}
nav a{background:#3b82f6;color:#fff;padding:.6rem 1rem;border-radius:6px;text-decoration:none;font-weight:600;}
main{max-width:1200px;margin:1.5rem auto;padding:0 1rem;}
.section{background:#fff;padding:1rem;border-radius:12px;box-shadow:0 6px 20px rgba(2,6,23,0.04);}
.section h2{font-size:1.25rem;margin-bottom:1rem;}
.controls{display:flex;gap:1rem;flex-wrap:wrap;margin-bottom:1rem; align-items: flex-end;}
.filter-group{display:flex;flex-direction:column;gap:.3rem;}
.filter-group label{font-weight:500;color:#475569;}
.filter-group select{padding:.5rem;border-radius:6px;border:1px solid #e2e8f0;background:#fff;color:#1e293b;}
.filter-group button{padding:.5rem 1rem;border-radius:6px;border:0;background:#3b82f6;color:#fff;font-weight:600;cursor:pointer;}
.filter-group button#compareBtn{background:#10b981;}
.filter-group button#chartBtn{background:#f59e0b;}
.filter-group button:hover{opacity: 0.9;}
.filter-group button#resetBtn{background:#6b7280;}
#chartContainer{position: relative;height: 450px;width: 100%;margin-top: 1rem;padding: 1rem;border: 1px solid #e2e8f0;border-radius: 8px;background: #fdfdfe;}
#overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);display:none;align-items:center;justify-content:center;z-index:1000;}
#overlay > div{max-width: 90%;max-height: 90%;overflow: auto;}
#overlay table{background:#fff;color:#1e293b;border-collapse:collapse;border-radius:8px;overflow:hidden;min-width:400px;box-shadow: 0 4px 15px rgba(0,0,0,0.2);}
#overlay th, #overlay td{padding:.8rem 1.2rem;border-bottom:1px solid #eee;text-align:center;}
#overlay th{background:#1e40af;color:#fff;position: sticky; top: 0; cursor: pointer;}
#overlay td.power-val{font-weight: 600;}
#overlay td.negative{color: #ef4444;}
#overlay td.positive{color: #10b981;}
#overlay button{margin:.8rem;padding:.5rem 1rem;border:none;border-radius:6px;background:#ef4444;color:#fff;font-weight:600;cursor:pointer;}
</style>
</head>
<body>

<header>
  <h1>Compare Players</h1>
  </header>

<nav>
  <a href="index.html">Dashboard</a>
  <a href="#">Compare</a>
  <a href="power.html">Add / Edit Power</a>
</nav>

<main>
    <p style="text-align:center; font-style:italic; color:#64748b;">Data is stored locally in your browser.</p>
    <section class="section">
        <h2>Comparison Setup</h2>
        <div class="controls">
            <div class="filter-group">
                <label for="playerSelect">Players (Select multiple)</label>
                <select id="playerSelect" multiple size="8"></select>
            </div>
            
            <div class="filter-group">
                <label for="comparisonMethod">Chart Method</label>
                <select id="comparisonMethod">
                    <option value="rawPower">Raw Power (Y-Axis: Total Power)</option>
                    <option value="percentChange">Percent Change (Y-Axis: % Growth)</option>
                </select>
            </div>

            <div class="filter-group" style="flex-direction: row; align-items: center;">
                <button id="chartBtn">Generate Chart</button>
                <button id="compareBtn">Summary Table</button>
                <button id="resetBtn">Reset</button>
            </div>
        </div>
    </section>

    <section class="section" style="margin-top: 1.5rem;">
        <h2>Power Trend Chart</h2>
        <div id="chartContainer">
            <p id="chartStatus">Select players and click "Generate Chart" or "Summary Table".</p>
            <canvas id="powerChart" style="display:none;"></canvas>
        </div>
    </section>
</main>

<div id="overlay">
  <div>
    <table id="compareTable"></table>
    <div style="text-align:center"><button id="closeOverlay">Close</button></div>
  </div>
</div>

<script>
// Key for localStorage
const LOCAL_STORAGE_KEY = 'localPowerTrackerData';

// Mock data to ensure charts have multiple points
const initialData = [
  // Alpha - Steady growth
  { player: 'Alpha', power: 150000, date: '2025-12-01' },
  { player: 'Alpha', power: 165000, date: '2025-12-03' },
  { player: 'Alpha', power: 180000, date: '2025-12-05' },
  { player: 'Alpha', power: 195000, date: '2025-12-09' },
  // Beta - Rapid growth
  { player: 'Beta', power: 100000, date: '2025-12-01' },
  { player: 'Beta', power: 130000, date: '2025-12-03' },
  { player: 'Beta', power: 160000, date: '2025-12-05' },
  { player: 'Beta', power: 200000, date: '2025-12-09' },
  // Gamma - Decline then recovery
  { player: 'Gamma', power: 250000, date: '2025-12-01' },
  { player: 'Gamma', power: 220000, date: '2025-12-03' },
  { player: 'Gamma', power: 210000, date: '2025-12-05' },
  { player: 'Gamma', power: 230000, date: '2025-12-09' },
  // Delta - Sparse data
  { player: 'Delta', power: 90000, date: '2025-12-02' },
  { player: 'Delta', power: 100000, date: '2025-12-09' },
];

let allPlayerEntries = {};
let comparisonData = [];
let powerTrendChart;
const playerColors = {};
const chartStatus = document.getElementById('chartStatus');
const powerChartCanvas = document.getElementById('powerChart');

// Utility functions
const formatNumber = (num, isPercent = false) => {
    if (num === null || isNaN(num) || num === Infinity) return 'N/A';
    return isPercent ? num.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 }) : Math.round(num).toLocaleString();
};
const getRandomColor = () => `rgb(${Math.floor(Math.random() * 200)},${Math.floor(Math.random() * 200)},${Math.floor(Math.random() * 200)})`;

/**
 * Loads data from localStorage, initializes if empty, and groups by player.
 * @returns {Array} The loaded and parsed array of power entries.
 */
function loadLocalData() {
    const dataString = localStorage.getItem(LOCAL_STORAGE_KEY);
    if (!dataString) {
        // Initialize with mock data if no data exists
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(initialData));
        return initialData;
    }
    return JSON.parse(dataString);
}

/**
 * Groups raw entries into an object keyed by player name.
 * @param {Array} entries - The raw array of power entries.
 */
function groupEntries(entries) {
    const grouped = {};
    const playerNames = new Set();
    entries.forEach(entry => {
        // Normalize date format (YYYY-MM-DD)
        const date = entry.date?.substring(0, 10) || new Date().toISOString().substring(0, 10);
        playerNames.add(entry.player);
        if (!grouped[entry.player]) grouped[entry.player] = [];
        grouped[entry.player].push({ power: entry.power, date });
    });
    return { grouped, playerNames: Array.from(playerNames).sort() };
}

/**
 * Main function to load and process player data.
 */
function loadAllPlayerEntries() {
    chartStatus.textContent = 'Processing player data...';
    const rawData = loadLocalData();
    const { grouped, playerNames } = groupEntries(rawData);
    allPlayerEntries = grouped;
    populatePlayers(playerNames);
    chartStatus.textContent = 'Select players and click "Generate Chart" or "Summary Table".';
}

function populatePlayers(playerNames) {
    const select = document.getElementById('playerSelect');
    if (playerNames.length === 0) {
        select.innerHTML = '<option disabled>No players found</option>';
        document.getElementById('chartBtn').disabled = true;
        document.getElementById('compareBtn').disabled = true;
        return;
    }
    select.innerHTML = playerNames.map(p => `<option value="${p}">${p}</option>`).join('');
    document.getElementById('chartBtn').disabled = false;
    document.getElementById('compareBtn').disabled = false;
}

function showOverlay() {
    const selectedNames = [...document.getElementById('playerSelect').options].filter(o => o.selected).map(o => o.value);
    if (selectedNames.length < 2) { alert('Select at least 2 players to compare.'); return; }
    
    comparisonData = [];
    selectedNames.forEach(name => {
        const entries = allPlayerEntries[name];
        if (!entries || entries.length === 0) return;

        // Sort entries by date
        entries.sort((a, b) => new Date(a.date) - new Date(b.date));
        
        // Find unique dates
        const uniqueDates = [...new Set(entries.map(e => e.date))].sort();
        
        // Find the latest power for the latest date
        const latestDate = uniqueDates[uniqueDates.length - 1];
        const latestPower = Math.max(...entries.filter(e => e.date === latestDate).map(e => e.power));
        
        // Find the latest previous date (second to last unique date)
        const previousDate = uniqueDates.length > 1 ? uniqueDates[uniqueDates.length - 2] : null;
        let previousPower = null;

        if (previousDate) {
            previousPower = Math.max(...entries.filter(e => e.date === previousDate).map(e => e.power));
        } else if (uniqueDates.length === 1 && entries.length > 1) {
             // Handle case where multiple entries exist on the *same* day, but only one unique date
             // We can't calculate a meaningful day-over-day change, so previousPower remains null.
        }

        let change = 0;
        if (previousPower !== null && previousPower !== 0) {
            change = ((latestPower - previousPower) / previousPower * 100);
        } else if (previousPower === 0 && latestPower > 0) {
             change = Infinity; // Growth from zero
        } else if (previousPower !== null && previousPower > 0) {
             // If previousPower > 0 and latestPower = 0 (or < 0), change is calculated normally
             change = ((latestPower - previousPower) / previousPower * 100);
        }

        comparisonData.push({ name, currentPower: latestPower, previousPower, change: parseFloat(change.toFixed(2)) });
    });
    
    renderComparisonTable();
    document.getElementById('overlay').style.display = 'flex';
}

let currentSort = { field: 'currentPower', asc: false };
function renderComparisonTable(sortBy = currentSort.field, ascending = currentSort.asc) {
    const table = document.getElementById('compareTable');
    comparisonData.sort((a, b) => {
        let valA = a[sortBy], valB = b[sortBy], comparison = 0;
        if (valA === Infinity) return ascending ? 1 : -1;
        if (valB === Infinity) return ascending ? -1 : 1;
        if (valA > valB) comparison = 1; else if (valA < valB) comparison = -1;
        return ascending ? comparison : -comparison;
    });

    table.innerHTML = `
        <tr>
            <th onclick="sortTable('name')">Player</th>
            <th onclick="sortTable('currentPower')">Current Power ${sortBy === 'currentPower' ? (ascending ? '▲' : '▼') : ''}</th>
            <th>Previous Power</th>
            <th onclick="sortTable('change')">% Change ${sortBy === 'change' ? (ascending ? '▲' : '▼') : ''}</th>
        </tr>
    `;
    comparisonData.forEach(r => {
        const changeVal = r.change === Infinity ? '+∞' : `${r.change >= 0 ? '+' : ''}${formatNumber(r.change, true)}%`;
        const changeClass = r.change > 0 ? 'positive' : (r.change < 0 ? 'negative' : '');
        table.innerHTML += `
            <tr>
                <td>${r.name}</td>
                <td class="power-val">${formatNumber(r.currentPower)}</td>
                <td>${formatNumber(r.previousPower)}</td>
                <td class="${changeClass}">${changeVal}</td>
            </tr>
        `;
    });
}
window.sortTable = (field) => {
    if (currentSort.field === field) currentSort.asc = !currentSort.asc;
    else { currentSort.field = field; currentSort.asc = false; }
    renderComparisonTable(currentSort.field, currentSort.asc);
};

function generateChart() {
    const selectedNames = [...document.getElementById('playerSelect').options].filter(o => o.selected).map(o => o.value);
    const method = document.getElementById('comparisonMethod').value;
    if (selectedNames.length === 0) { chartStatus.textContent = 'Select at least one player.'; powerChartCanvas.style.display = 'none'; return; }
    if (powerTrendChart) powerTrendChart.destroy();
    
    let allDates = new Set();
    selectedNames.forEach(name => {
        const entries = allPlayerEntries[name] || [];
        entries.forEach(e => allDates.add(e.date));
    });
    const sortedDates = Array.from(allDates).sort();
    
    const datasets = selectedNames.map(player => {
        const entries = allPlayerEntries[player] || [];
        if (!playerColors[player]) playerColors[player] = getRandomColor();
        
        // Use the highest power for any given date
        const datePowerMap = new Map();
        entries.forEach(entry => {
            const existing = datePowerMap.get(entry.date) || 0;
            datePowerMap.set(entry.date, Math.max(existing, entry.power));
        });

        const rawData = sortedDates.map(d => datePowerMap.get(d) ?? null);
        const finalData = (method === 'rawPower') ? rawData : calculatePercentChangeSeries(rawData);
        
        return { 
            label: player, 
            data: finalData, 
            borderColor: playerColors[player], 
            backgroundColor: playerColors[player].replace('rgb', 'rgba').replace(')', ',0.5)'), 
            spanGaps: true, 
            tension: 0.2, 
            borderWidth: 2, 
            pointRadius: 4 
        };
    }).filter(d => d.data.some(v => v !== null)); // Filter out datasets with no valid data

    const ctx = powerChartCanvas.getContext('2d');
    const chartTitle = (method === 'rawPower') ? 'Raw Power Trend' : 'Percent Change Trend';
    const yAxisLabel = (method === 'rawPower') ? 'Total Power' : '% Change';
    
    const tooltipCallback = {
        label: ctx => {
            let l = ctx.dataset.label || '';
            if (l) l += ':';
            if (ctx.parsed.y !== null) {
                l += method === 'rawPower' ? formatNumber(ctx.parsed.y) : `${ctx.parsed.y > 0 ? '+' : ''}${formatNumber(ctx.parsed.y, true)}%`;
            }
            return l;
        }
    };
    
    powerTrendChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: sortedDates,
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: { display: true, text: chartTitle, font: { size: 16 } },
                tooltip: { callbacks: tooltipCallback }
            },
            scales: {
                x: { title: { display: true, text: 'Date' }, type: 'category' },
                y: {
                    title: { display: true, text: yAxisLabel },
                    beginAtZero: method !== 'rawPower', // Only force zero for % change charts
                    ticks: {
                        callback: (value) => method === 'rawPower' ? formatNumber(value) : value + '%'
                    }
                }
            }
        }
    });
    
    chartStatus.style.display = 'none';
    powerChartCanvas.style.display = 'block';
}

/**
 * Calculates a series of percent change values from a series of raw power values.
 * Change is calculated based on the previous *recorded* data point.
 */
function calculatePercentChangeSeries(raw) {
    const percent = [];
    for (let i = 0; i < raw.length; i++) {
        const current = raw[i];
        if (current === null) {
            percent.push(null);
            continue;
        }

        let previous = null;
        let last = i - 1;
        
        // Find the most recent non-null previous power entry
        while (last >= 0) {
            if (raw[last] !== null) {
                previous = raw[last];
                break;
            }
            last--;
        }

        if (previous === null) {
            percent.push(null);
        } else if (previous === 0) {
            // Growth from 0 is technically infinite, but we cap it high for display
            percent.push(current > 0 ? 10000 : 0);
        } else {
            percent.push(parseFloat(((current - previous) / previous * 100).toFixed(2)));
        }
    }
    return percent;
}

// Initial load
document.addEventListener('DOMContentLoaded', loadAllPlayerEntries);

// Event Listeners
document.getElementById('compareBtn').onclick = showOverlay;
document.getElementById('chartBtn').onclick = generateChart;
document.getElementById('resetBtn').onclick = () => {
    [...document.getElementById('playerSelect').options].forEach(o => o.selected = false);
    if (powerTrendChart) powerTrendChart.destroy();
    powerChartCanvas.style.display = 'none';
    chartStatus.style.display = 'block';
    chartStatus.textContent = 'Select players and click "Generate Chart" or "Summary Table".';
};
document.getElementById('closeOverlay').onclick = () => document.getElementById('overlay').style.display = 'none';
</script>
</body>
</html>
